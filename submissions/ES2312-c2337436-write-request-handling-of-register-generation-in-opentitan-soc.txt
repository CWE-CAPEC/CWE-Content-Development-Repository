SUBMISSION COMMUNICATION ID: ES2312-c2337436

ACTION TYPE: New Entry

SUBMISSION STATUS: Det-Received

AFFECTED CWES: 

ORIGIN: sub-server

SUBMISSION DATE: 2023-12-20 03:53:09

ISSUES: yes/active

ISSUE DETAILS: SUB.MISC

PUBTRACKER: #61

MTRACKER: #964

GITHUBUSER: srivastava-amisha

SUBMISSION TYPE: Hardware

NAME: Lack of Feedback for Unexecuted Operations Across System Interfaces


# 2. SUMMARY (required)

# The summary consists of only one or two sentences that describe the
# weakness itself, i.e. the mistake that is made.
#
# See details at:
# https://cwe.mitre.org/community/submissions/guidelines.html#summary

SUMMARY:

The weakness occurs when systems discard or ignore operations without
providing feedback, error handling, or logging, leading to potential
data loss, security vulnerabilities, and system instability. It
highlights the silent omission of feedback in cases where operations
fail or are unexecuted due to system constraints or design choices.


EXTENDED DESCRIPTION:

This weakness focuses on the silent omission of feedback when
operations are not just errored, but unexecuted or ignored due to
system constraints or design decisions. This weakness is not limited
to any specific technology or context, but can occur in any system
where operations can be discarded without feedback or notification. A
primary example of this weakness is found in the OpenTitan
System-on-Chip's scmi_reg_top module, where write requests to reserved
addresses are correctly identified as errors and discarded, but
without any feedback provided.

Therefore, this weakness category captures issues across various
hardware interfaces where operations are discarded without any
feedback, error handling, or logging. Such omissions can lead to data
loss, security vulnerabilities, and system instability, with potential
impacts ranging from minor to catastrophic.

1) SoC systems, like OpenTitan: The example of write operations to
reserved addresses being discarded without feedback directly
exemplifies the weakness. It showcases a specific case where the
system's failure to inform about discarded operations could lead to
misinterpretations about the system's state or the success of
operations, fitting the weakness perfectly.

2) Microcontroller interrupt systems: Ignored interrupts due to
priority conflicts or system errors without signaling highlight a
failure in the system's communication about operational
decisions. This directly contributes to the weakness by showing how
critical feedback mechanisms are absent in scenarios where system
limitations affect operation execution.

3) Network interface controllers: The failure to report buffer
overflows and the subsequent dropping of packets without notification
is a clear instance of the system not providing feedback on crucial
operational failures, leading to data loss and potential communication
breakdowns.


************************************************************************************************


MODES OF INTRODUCTION:

Phase: Architecture and Design

Note: This weakness can be introduced during the architecture and
design phase when the system does not incorporate proper mechanisms
for error reporting or feedback for discarded operations, such as when
handling reserved addresses or unexecuted instructions.

Phase: Implementation

Note: It can also arise during implementation if developers fail to
include appropriate feedback or logging for critical operations. This
leads to silent failures in certain scenarios like interrupt handling
or network buffer overflows.



************************************************************************************************

APPLICABLE PLATFORMS:

# This element specifies the programming languages, operating systems,
# architectures, and technologies in which this weakness is usually
# found. If an element does not apply to this submission, you can use
# the "Not X-Specific" where "X" is the type of element.

# If there are multiple languages, OSes, architectures, and/or
# technologies, then list each one separately.
# 
# See details at:
# https://cwe.mitre.org/community/submissions/guidelines.html#platforms


# Values for Prevalence: Often, Sometimes, Rarely, Undetermined

# Values for Language Name: Ada, ARM Assembly, ASP, ASP.NET, Basic, C,
#    C++, C#, COBOL, Fortran, F#, Go, HTML, Java, JavaScript, JSON,
#    JSP, Objective-C, Pascal, Perl, PHP, Pseudocode, Python, Ruby,
#    Rust, Shell, SQL, Swift, VB.NET, Verilog, VHDL, XML, x86
#    Assembly, Other

Language Name: C
Prevalence: Often


Language Name: C++
Prevalence: Often


Language Name: Verilog
Prevalence: Often

# Values for Language Class: Assembly, Compiled, Hardware Description
#    Language, Interpreted, Not Language-Specific

Language Class: Hardware Description Language
Prevalence: Often

Language Class: Not Language-Specific
Prevalence: Often


# Values for Operating System Name: AIX, Android, BlackBerry OS,
#    Chrome OS, Darwin, FreeBSD, iOS, macOS, NetBSD, OpenBSD, Red Hat,
#    Solaris, SUSE, tvOS, Ubuntu, watchOS, Windows 9x, Windows
#    Embedded, Windows NT

Operating System Name: Embedded
Prevalence: Sometimes

Operating System Name: Ubuntu
Prevalence: Sometimes

# Values for Operating System Class: Linux, macOS, Unix, Windows,
#    Not OS-Specific


Operating System Class: Not OS Specific
Prevalence: Often


# Values for Architecture Name: Alpha, ARM, Itanium, Power
#     Architecture, SPARC, x86, Other


Architecture Name: ARM
Prevalence: Sometimes

Architecture Name: x86
Prevalence: Sometimes


# Values for Architecture Class: Embedded, Microcomputer, Workstation,
#     Not Architecture-Specific

Architecture Class: Embedded
Prevalence: Often


# Values for Technology Name: Web Server, Database Server, Accelerator
#    Hardware, Analog and Mixed Signal Hardware, Audio/Video Hardware,
#    Bus/Interface Hardware, Clock/Counter Hardware, Communication
#    Hardware, Controller Hardware, Memory Hardware, Microcontroller
#    Hardware, Network on Chip Hardware, Power Management Hardware,
#    Processor Hardware, Security Hardware, Sensor Hardware, Storage
#    Hardware, Test/Debug Hardware


Technology Name: Security Hardware
Prevalence: Often

Technology Name: Processor Hardware
Prevalence: Often

Technology Name: Microcontroller Hardware
Prevalence: Often

# Values for Technology Class: Client Server, Cloud Computing, ICS/OT,
#     Mainframe, Mobile, N-Tier, SOA, System on Chip, Web Based, Not
#     Technology-Specific
	
Technology Class: System on Chip
Prevalence: Often


************************************************************************************************

COMMON CONSEQUENCES:

# This element will cover the typical negative security impact (or
# impacts) that occurs if this weakness can be exploited by an
# attacker. Each Consequence must include a Scope and Impact. Both the
# Likelihood and Note elements are optional.
#
# See details at:
# https://cwe.mitre.org/community/submissions/guidelines.html#conseq



# Values for Scope: Confidentiality, Integrity, Availability, Access
#    Control, Accountability, Authentication, Authorization,
#    Non-Repudiation, Other


# Values for Impact: Modify Memory, Read Memory, Modify Files or
#    Directories, Read Files or Directories, Modify Application Data,
#    Read Application Data, DoS: Crash, Exit, or Restart, DoS:
#    Amplification, DoS: Instability, DoS: Resource Consumption (CPU),
#    DoS: Resource Consumption (Memory), DoS: Resource Consumption
#    (Other), Execute Unauthorized Code or Commands, Gain Privileges
#    or Assume Identity, Bypass Protection Mechanism, Hide Activities,
#    Alter Execution Logic, Quality Degradation, Unexpected State,
#    Varies by Context, Reduce Maintainability, Reduce Performance,
#    Reduce Reliability, Other


# Values for Likelihood: High, Medium, Low, Unknown

Scope: Confidentiality

Impact: Read Memory, Read Files or Directories
Likelihood: Medium

Note: Critical data may be exposed if operations are unexecuted or
discarded silently, allowing attackers to exploit the lack of
feedback.


Scope: Integrity

Impact: Modify Memory, Modify Files or Directories

Likelihood: Medium

Note: Operations may proceed based on incorrect assumptions,
potentially causing data corruption or incorrect system behavior.

Scope: Availability

Impact: DoS: Resource Consumption (Memory), DoS: Crash, Exit, or Restart

Likelihood: High

Note: Unhandled discarded operations can lead to resource exhaustion,
triggering system crashes or denial of service.



************************************************************************************************

# 8. DEMONSTRATIVE EXAMPLES (required)

DEMONSTRATIVE EXAMPLES:

# The entry should have one or more demonstrative examples, but
# submitters should not put significant effort into these until the CWE
# team has reviewed and accepted the general concepts behind the
# submission. Submissions can include example information for either
# Software, Hardware, or both, as relevant.

# "BAD CODE" and "GOOD CODE" can be code snippets, descriptions of a
# design or architecture, or an algorithm or protocol.
#
# * If you would like to submit diagrams/images to support any
# weakness descriptive examples, please attach it to the email
# submission in a png format and reference it by filename where
# desired. For an example, please see:
# https://cwe.mitre.org/data/definitions/1256.html

# See details at:
# https://cwe.mitre.org/community/submissions/guidelines.html#demox

# Values for Language Name: Ada, ARM Assembly, ASP, ASP.NET, Basic, C,
#    C++, C#, COBOL, Fortran, F#, Go, HTML, Java, JavaScript, JSON,
#    JSP, Objective-C, Pascal, Perl, PHP, Pseudocode, Python, Ruby,
#    Rust, Shell, SQL, Swift, VB.NET, Verilog, VHDL, XML, x86
#    Assembly, Other


INTRO TEXT:
 
This example demonstrates how ignoring interrupts without feedback can
lead to missed critical operations. In an embedded system,
high-priority interrupts can preempt lower-priority ones. However, if
the lower-priority interrupts are silently dropped due to resource
constraints, it may lead to system malfunctions.
 
BAD CODE:
LANGUAGE: C
 
// BAD CODE: Interrupt handling without feedback
void interrupt_handler(int irq) {
    if (irq_priority[irq] < current_priority) {
        return;  // No feedback on discarded interrupt
    }
    process_interrupt(irq);  // Proceed with interrupt processing
}
 
 
EXPLANATORY TEXT:
 
In this example, if the interrupt’s priority is lower than the
currently active one, the interrupt is discarded without any
feedback. This omission can cause developers to misinterpret the state
of the system, leading to incorrect assumptions and potential system
failures, such as missed sensor readings.

In the good code version, the system uses structured logging to
provide visibility into discarded interrupts. This allows developers
to track missed interrupts and optimize the system.
 
GOOD CODE:
LANGUAGE: C

// Priority threshold for active interrupts
int current_priority = 3;

// Simulated priority levels for different IRQs
int irq_priority[5] = {1, 2, 3, 4, 5};

void process_interrupt(int irq) {
    printf("Processing interrupt %d\n", irq);
}

void interrupt_handler(int irq) {
    if (irq_priority[irq] < current_priority) {
        // Log the dropped interrupt using structured feedback
        fprintf(stderr, "Warning: Interrupt %d dropped (Priority: %d < Current: %d)\n", 
                irq, irq_priority[irq], current_priority);
        exit(EXIT_FAILURE);  // Exit with failure status to indicate a critical issue.
    }
    process_interrupt(irq);
}

 
 
---------------
 
INTRO TEXT:
 
This example demonstrates how network packets can be lost without
notification when a buffer overflows. Such silent failures can lead to
data loss and communication breakdowns, especially in real-time
systems.
 
BAD CODE:
LANGUAGE: C
 
// BAD CODE: Packet dropping without notification
#define BUFFER_SIZE 1024
int buffer[BUFFER_SIZE];
int buffer_index = 0;

void receive_packet(int packet) {
    if (buffer_index >= BUFFER_SIZE) {
        return;  // Packet silently discarded
    }
    buffer[buffer_index++] = packet;
}
 
 
EXPLANATORY TEXT:
 
In the bad version, packets are discarded when the buffer is full, but
no feedback is provided. This lack of visibility can lead to
communication failures and debugging challenges, as developers won’t
know why packets are missing.

In the improved version, a log entry is generated for every dropped
packet. This feedback helps network administrators or developers
identify buffer overflow issues and optimize resource management
accordingly.

GOOD CODE:
LANGUAGE: C

#define BUFFER_SIZE 1024
int buffer[BUFFER_SIZE];
int buffer_index = 0;

// Logs error and returns false if the packet is dropped
bool receive_packet(int packet) {
    if (buffer_index >= BUFFER_SIZE) {
        fprintf(stderr, "Error: Packet %d dropped (Buffer Full)\n", packet);
        return false;  // Indicate that the packet was not received
    }
    buffer[buffer_index++] = packet;
    return true;  // Indicate successful packet reception
}

 
 
************************************************************************************************

OBSERVED EXAMPLES:

# Where known, the submission should identify multiple
# publicly-reported vulnerabilities in real-world products that
# exhibit the weakness. If possible, include CVE Identifier, its
# corresponding weblink, and a short summary. If a CVE ID is
# unavailable, use the Link to point to the reference that explains
# the vulnerability.

# The ID should be the CVE Identifier, if available. If not available,
# then supply a title or alternate ID used by the reference.

# The Link should be the URL to the reference that explains the
# weakness that leads to the vulnerability.

# The ObexSummary should be a brief sentence or two that focuses solely on
# the weakness in the affected product.

# See details at:
# https://cwe.mitre.org/community/submissions/guidelines.html#obex

ID: <<CVE1>>

Link: <<LINK1>>

ObexSummary: <<SUM1>>


ID: <<CVE2>>

Link: <<LINK2>>

ObexSummary: <<SUM2>>


ID: <<CVE3>>

Link: <<LINK3>>

ObexSummary: <<SUM3>>


ID: <<CVE4>>

Link: <<LINK4>>

ObexSummary: <<SUM4>>



************************************************************************************************

DETECTION METHODS:

# Detection Methods should identify commonly-used methods of finding
# the weakness within the product's code, design, etc. This is NOT
# intended for detecting how the weakness is exploited in a
# vulnerability. There can be one or more methods provided.

# Values for Method: Automated Analysis, Automated Dynamic Analysis,
#    Automated Static Analysis, Automated Static Analysis - Source
#    Code, Automated Static Analysis - Binary or Bytecode, Fuzzing,
#    Manual Analysis, Manual Dynamic Analysis, Manual Static Analysis,
#    Manual Static Analysis - Source Code, Manual Static Analysis -
#    Binary or Bytecode, White Box, Black Box, Architecture or Design
#    Review, Dynamic Analysis with Manual Results Interpretation,
#    Dynamic Analysis with Automated Results Interpretation, Formal
#    Verification, Simulation / Emulation, Other

# Values for Effectiveness: High, Moderate, Opportunistic, Limited, None


Method: Automated Static Analysis - Source Code

Desc: Scans code for missing error handling or feedback mechanisms.

Effectiveness: High

Notes: Can identify common issues early in the development phase.


Method: Manual Code Review

Desc: Experts manually inspect the code for unhandled operations.

Effectiveness: Moderate

Notes: Useful for identifying design-level omissions.


************************************************************************************************

POTENTIAL MITIGATIONS:

# This element should cover one or more techniques that will eliminate
# and/or reduce the frequency or impact of the weakness. Each mitigation
# must include a Phase and Description, while the Effectiveness element
# is optional. A descriptive Effectiveness Note is also optional.

# See details at:
# https://cwe.mitre.org/community/submissions/guidelines.html#mitigations


# Values for Phase: Policy, Requirements, Architecture and Design,
#    Implementation, Build and Compilation, Testing, Documentation,
#    Bundling, Distribution, Installation, System Configuration,
#    Operation, Patching and Maintenance, Porting, Integration,
#    Manufacturing, Decommissioning and End-of-Life

# Values for Effectiveness: High, Moderate, Limited, Incidental,
#    Discouraged Common Practice, Defense in Depth, None



Phase: Architecture and Design

Description: Incorporate logging and feedback mechanisms during the
design phase to ensure proper handling of discarded operations.

Effectiveness: High

Effectiveness Notes: Addressing the issue at the design stage prevents
the weakness from manifesting later.


Phase: Implementation

Description: Developers should ensure that every critical operation
includes proper logging or error feedback mechanisms.

Effectiveness: Moderate

Effectiveness Notes: Implementation-level checks complement
design-phase measures.


************************************************************************************************

RELATED WEAKNESSES:

   Other CWE-1191
   Other CWE-1256
   ChildOf CWE-392

REFERENCES:

Title: Improper Neutralization in Write Request Handling of Register Generation in OpenTitan SoC

URL: https://docs.google.com/presentation/d/1mw7d3muWdAJa6RSuKzJVbeBHTE38kzSL/edit?usp=sharing&ouid=107690590607250324314&rtpof=true&sd=true

Author: Amisha Srivastava

Date: <<put the publication date here - either "YYYY-NN-DD", "Monthname, YYYY", or "YYYY">>


ACTIVE ISSUES:

SUB.MISC - "Miscellaneous/other problem"

Description: The submission has some other problem that is not covered
elsewhere.

Resolution: This will depend on the nature of the problem.

Comments: During stage 2 as the description is refined, some more text
is needed to clarify what is meant for "...operations are...unexecuted
or ignored due to system constraints or design decisions". Are there
any exceptions to this blanket statement when it wouldn't be
considered a weakness? For example, for transient execution,
operations are discarded without notifying the user. Perhaps in the
submission it is assumed to be referring to operations that a user
submits, but it should be specified? What about scenarios where a user
is issuing operations against privileged memory and feedback about
those operations leak information? That may be covered by a different
weakness, but there should be some clarification around this point.

Response: <SUBMITTER SHOULD REPLY HERE>


RESOLVED ISSUES:

SUB.UNCLEAR - "Unclear weakness"

Description: The submission's name and/or description does not clearly
identify a weakness, or it is written in a way that is vague and could
cause the submission to be incorrectly mapped to.

Resolution: An initial submission (or full submission) cannot progress past
the consultation phase until SUB.UNCLEAR is addressed.

Comments: This submission appears to be a report about a specific
vulnerability in a specific product, which the submitter wants to
disclose in a public report.  If that is the case, then the
appropriate action is to request a CVE identifier via
https://cveform.mitre.org/ .

If this is not a request about a specific vulnerability, then this
submission could possibly be used as a demonstrative example in the
appropriate CWE entry - as long as the vulnerability has been
published.

Please clarify the situation.

Response: Thank you for your feedback. To clarify, our submission
identifies a generalized weakness that can be better titled “Lack of
Feedback for Unexecuted Operations Across System Interfaces”. Unlike
the broader issue of failing to indicate error conditions with status
codes or return values, this weakness focuses on the silent omission
of feedback when operations are not just errored, but unexecuted or
ignored due to system constraints or design decisions. This weakness
is not limited to any specific technology or context, but can occur in
any system where operations can be discarded without feedback or
notification. A primary example of this weakness is found in the
OpenTitan System-on-Chip’s scmi_reg_top module, where write requests
to reserved addresses are correctly identified as errors and
discarded, but without any feedback provided.

Therefore, this weakness category captures issues across various
hardware interfaces where operations are discarded without any
feedback, error handling, or logging. Such omissions can lead to data
loss, security vulnerabilities, and system instability, with potential
impacts ranging from minor to catastrophic.

1) SoC systems, like OpenTitan: The example of write operations to
reserved addresses being discarded without feedback directly
exemplifies the weakness. It showcases a specific case where the
system's failure to inform about discarded operations could lead to
misinterpretations about the system's state or the success of
operations, fitting the weakness perfectly.

2) Microcontroller interrupt systems: Ignored interrupts due to
priority conflicts or system errors without signaling highlight a
failure in the system's communication about operational
decisions. This directly contributes to the weakness by showing how
critical feedback mechanisms are absent in scenarios where system
limitations affect operation execution.

3) Network interface controllers: The failure to report buffer
overflows and the subsequent dropping of packets without notification
is a clear instance of the system not providing feedback on crucial
operational failures, leading to data loss and potential communication
breakdowns.

In addition, to address the specific instance within the OpenTitan
SoC, a CVE report can be submitted, where: the CVE identification
process will address the particular vulnerability, while this CWE
submission will serve to inform the broader software and hardware
development communities about the general weakness.

----------

SUB.RELS - "Unclear relationships"

Description: The submission suggests some relationships, but the
name/description is not explained in a way in which the relationship is
relevant; or, the weakness is apparent, but it is not clear what the best
parent/child relationship(s) would be.

Resolution: The submission cannot progress to the next phase if SUB.UNCLEAR
is present. It can progress to other phases if the CWE Team agrees that the
potential relationships may require closer investigation.  The submission
cannot progress to the publication stage until clear relationships and
direct parents are identified. The CWE Team may decide to use high-level
relationships (e.g., to Pillars) if deeper problems such as SUB.ABS.SUBTREE
exist and cannot be quickly resolved.

Comments: this appears to be an example of CWE-392: Missing Report of
Error Condition.  It does not appear to be related to CWE-1191 or
CWE-1256, since both are related to the ability for an adversary to
bypass intended access control, but the submission is not saying that
there is a problem with restricting access to the write
operation. Please confirm.

Response: The submission intended to highlight a weakness where write
operations to reserved addresses are not reported back to the user due
to a lack of feedback mechanisms. This indeed aligns more closely with
CWE-392: "Missing Report of Error Condition" as it directly concerns
the system's failure to notify the user of unsuccessful
operations. Given this clarification, I propose that the primary
relationship of this vulnerability should be with CWE-392 as the
direct parent, clarifying the misalignment with CWE-1191 and CWE-1256.

----------

SUB.ABS.LOWLEVEL - "Low level of abstraction"

Description: The submission identifies an issue, but its abstraction might
be too low-level to merit its own CWE entry. If it is focused on a
particular technology, framework, protocol, or function, then it might not
be unique enough to get its own CWE ID.  This might lead to modification of
an existing entry to include the additional details, or creation of a
higher-level entry for which the submission is one example. (Note: some
older CWE entries have this problem and would not be published today,
generally because they were too specific to a particular language.)

Resolution: The submission will be allowed to progress to later phases once
the more-general concept is appropriately identified and described. The
original, lower-level submission will serve as a primary example of the
more general concept.

Comments: This submission appears to be a report about a specific
vulnerability (not reporting errors) in a specific product
(OpenTitan), but CWE entries are about the types of weaknesses that
lead to vulnerabilities. Unless other problems are resolved (see
above), we cannot move forward with this submission.

Response: Acknowledging the feedback on the specificity of our
submission, we have refined our focus to present a more generalized
weakness, aptly titled "Lack of Feedback for Unexecuted Operations
Across System Interfaces." This weakness encapsulates the critical
issue where systems, spanning a spectrum of technologies, fail to
notify or log the non-execution or disregard of operations due to
various reasons including system constraints, design decisions, or
errors. This can occur across a broad range of system interfaces, from
hardware components like SoC modules to communication protocols, thus
leading to vulnerabilities. The responses for the aforementioned
problems aim to resolve the issue about the generalizability of this
weakness.



TIMELINE:

Received: 2023-12-20

Ack-Receipt: 2024-01-11

Init-Review: 2024-01-11

Init-Consultation: 2024-02-06

Init-Declined: YYYY-MM-DD

Init-Accepted: 2024-06-06

Det-Requested: 2024-09-11

Det-Received: 2024-10-13

Det-Review: YYYY-MM-DD

Det-Consultation: YYYY-MM-DD

Det-Accepted: YYYY-MM-DD

Internal-Update: YYYY-MM-DD

Final-Coord: YYYY-MM-DD

CWE-Assigned: YYYY-MM-DD

CWE-Modified: YYYY-MM-DD

CWE-Published: YYYY-MM-DD

Post-Publication: YYYY-MM-DD

Closed: YYYY-MM-DD




COMMUNICATIONS LOG:
2024-01-09 received email
2024-01-09 sent email
2024-01-10 sent email
2024-01-10 received email
2024-01-11 sent email
2024-01-11 sent email
2024-02-06 received email
2024-02-06 sent email
2024-03-01 received email
2024-04-12 received email
2025-05-16 sent email
2024-06-06 sent email
2024-09-01 sent email
